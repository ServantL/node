# 线程属性

## 1、线程优先级

​	==每一个线程都有一个**优先级**。默认情况下，一个线程继承它的父线程的优先级。可以用**setPriority**方法提高或降低任何一个线程的优先级。==可以将优先级设置为MIN_PRIORITY（在Thread类中定义为1）与MAX_PRIORITY（定义为10）之间的任何值。NORM_PRIORITY被定义为5。

​	每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是**高度依赖于系统**的。当虚拟机依赖于宿主机平台的线程实现机制时，java线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。

​	*例如，Windows有7个优先级别。一些java优先级将映射到相同的操作系统优先级。在Sun为Linux提供的java虚拟机，线程的优先级被忽略——所有线程具有相同的优先级。*

​	==为优先级而烦恼是事出有因的。不要将程序构建为功能的正确性依赖于优先级。==

​	==如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。没当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程完全饿死。==



## 2、守护线程

​	==可以通过调用**setDaemon(true)**将线程转换为**守护线程（daemon thread）**。这一方法必须在线程启动之前调用。守护线程的唯一用途是为其他线程提供服务。==*计时线程就是一个例子，它定时地发送“时间滴答”信号给其他线程或清空过时的高速缓存项的线程。*当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。

​		

## 3、未捕获异常处理器

​	==线程的**run**方法不能抛出任何被检测的异常，但是，不被检测的异常会导致线程终止。在这种情况下，线程就死亡了。==

​	但是，不需要任何catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

​	该处理器必须属于一个实现**Thread.UncaughtExceptionHandler**接口的类。这个接口只有**UNcaughtException( Thread t, Throwable e)**一个方法。

​	从java SE 5.0起，可以用**setUncaughtExceptionHandler**方法为任何线程安装一个处理器。也可以用**Thread**类的静态方法**setDefaultUncaughtExceptionHandler**为所有线程安装一个默认的处理器。替换处理器可以使用日志API发送未捕获异常的报告到日志文件。

​	如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的**ThreadGroup**对象。

> 线程组是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组，但是，也可能会建立其他的组。从java SE 5.0起引入了更好的特性用于线程集合的操作。不要在自己的程序中使用线程组。

​	**ThreadGroup**类实现了**Thread.UncaughtExceptionHandler**接口。它的**uncaughtException**方法做如下操作：

1. 如果该线程组有父线程组，那么父线程组的**uncaughtException**方法被调用

2. 否则，如果**Thread.getDefaultExceptionHandler**方法返回一个非空的处理器，则调用该处理器

3. 否则，如果**Throwable**是**ThreadDeath**的一个实例，什么都不做

4. 否则，线程的名字以及**Throwable**栈踪迹被输出到**System.err**上

   这是在程序中肯定看到过许多次的栈踪迹











































