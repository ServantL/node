# 具体的集合

![image-20200105154644242](D:\Typora\data\javaSE\集合\images\具体的集合.assets\image-20200105154644242.png)==除了以**Map**结尾的类实现了**Map**接口之外，其他的类都实现了**Collection**接口==

## 1、链表

==在java程序设计语言中，所有链表实际上都是**双向链接的（doubly linked）**，即每个结点还存在放着指向前驱结点的引用==
![image-20200105154736255](D:\Typora\data\javaSE\集合\images\具体的集合.assets\image-20200105154736255.png)
**注意：**链表与泛型集合之间有一个重要的区别。链表是一个**有序集合（ordered collection）**，每个对象的位置十分重要。**LinkedList.add**方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所有这种依赖于位置的**add**方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。例如，**Set**集合类中的元素完全无序，因此，在**Iterator**接口中就没有**add**方法。相反地，
集合类库提供了子接口**ListIterator**，其中包含**add**方法：

```java
interface ListIterator<E> extends Iterator<E>
{
    void add(E element);
}
```

与**Collection.add**不同，这个方法不返回**boolean**类型的值，它假定添加操作总会改变链表。另外，**ListIterator**接口有两个方法，可以用来反向遍历链表。
```java
E previous( );
boolean hasPrevious( );
```

与**next**方法一样，**previous**方法返回越过的对象
**LinkedList**类的**listIterator**方法返回一个实现了**ListIterator**接口的迭代器对象
```java
ListIterator<String> iter = staff.listIterator( );
```
* **add**方法在迭代器位置之前添加一个新对象。

* 如果多次调用**add**方法，将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前

* 当用一个刚刚由**Iterator**方法返回，并且指向链表表头的迭代器调用**add**操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最优一个元素树（即**hasNext**返回false），添加的元素将变成列表的新表尾。如果链表有n个元素，有n+1个位置可以添加新元素。这些位置与迭代器的n+1个可能的位置相对应。

* **add**方法只依赖于迭代器的位置，而**remove**方法依赖于迭代器的状态

* **set**方法用一个新元素取代调用**next**或**previous**方法返回的上一个元素。
  *例：*

  ```java
  ListIterator<String> iter = list.listIterator( );
  String oldValue = iter.next( ); // return first element
  iter.set(newValue); // set first element to newValue
  ```

  > 在用“光标”类比时要格外小心。**remove**操作与**BACKSPACE**键的工作方式不太一样。在调用**next**之后，**remove**方法确实与**BACKSPACE**键一样删除了迭代器左侧的元素。但是，如果调用**previous**就会将右侧的元素删除掉，并且不能再同一行中调用两次**remove**。

可以想象，如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个**ConcurrentModificationException**异常
*例：*

```java
List<String> list = ...;
ListIterator<String> iter1 = list.listIterator( );
ListIterator<String> iter2 = list.listIterator( );
iter1.next( );
iter1.remove( );
iter2.next( ); // throws ConcurrentModificationException
```
* 为了避免发生并发修改的异常，请遵循下述简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器

* 有一种简单的方法可以检测到并发修改的问题。集合可以跟踪改写操作（诸如添加或删除元素）的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致，抛出一个**ConcurrentModificationExcpetion**异常

  > 对于并发修改列表的检测有一个奇怪的例外。==链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。**set**操作不被视为结构性修改。==可以将多个迭代器附加给一个链表，所有的迭代器都调用**set**方法对现有结点的内容进行修改。

列表迭代器接口还有一个方法，可以告之当前位置的索引。实际上，从概念上讲，由于java迭代器指向两个元素之间的位置，所以可以同时产生两个索引：**nextIndex**方法返回下一次调用**next**方法时返回元素的整数索引；**previousIndex**方法返回下一次调用**previous**方法时返回元素的整数索引。当然，这个索引只比**nextIndex**返回的索引值小1。这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。最后需要说一下，如果有一个整数索引n，**listt.listIterator(n）**将返回一个迭代器，这个迭代器指向索引为n的元素前面的位置。也就是说，调用**next**与调用**list.get(n）**会产生同一个元素，只是获得这个迭代器的效率比较低。

## 2、数组列表

**List**接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用**get**和**set**方法随机地访问每个元素。后者不适用于链表，但对数组却很有用。**ArrayList**封装了一个动态再分配的对象数组，这个类也实现了**List**接口。

> 在需要动态数组时，可能会使用**Vector**类。原因很简单：**Vector**类的所有方法都是同步的。可以由两个线程安全地访问一个**Vector**对象。但是，如果由一个线程访问**Vector**，代码要在同步操作上消费大量的实际。而**ArrayList**方法不是同步的，因此，建议在不需要同步时使用**ArrayList**，而不要使用**Vector**。

## 3、散列集

​	==可以快速地查找所需要的对象的数据结构，就是**散列表（hash table）**。散列表为每个对象计算一个整数，称为**散列码（hash code）**==。散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。它们是由**String**类的**hashCode**方法产生 。

​	在java中，==散列表用链表数组实现。每个列表被称为**桶（bucket）**==，如图。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。*例如，如果某个对象的散列码为76268，并且有128个桶，对象应该保存在第108号桶中（76268除以128余108）。*或许会很幸运，在这个桶中没有其他元素，此时将元素直接插入到桶中就可以了。当然，==有时候会遇到桶被占满的情况，这种现象被称为**散列冲突（hash collision）**。==这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，且桶的数目也足够大，需要比较的次数就会很少。

![image-20200105161405401](D:\Typora\data\javaSE\集合\images\具体的集合.assets\image-20200105161405401.png)

* 如果想更多地控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能。

* 如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的75%~150%。最好将桶数设置为一个素数，以防键的集聚。标准类库使用的桶数是2的幂，默认值为16（为表大小提供的任何值都将被自动地转换为2的下一个幂）

* ==如果散列表太满，就需要**再散列（rehashed）**。==如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。==**装填因子（load factor）**决定何时对散列表进行再散列。==*例如，如果装填因子为0.75（默认值），而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。*

​	散列表可以用于实现几个重要的数据结构。其中最简单的是**Set**类型。==**Set**是没有重复元素的元素集合==。**Set**的**add**方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。

​	java集合类库提供了一个**HashSet**类，它实现了基于散列表的集。可以用**add**方法添加元素。**contains**方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。

​	散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用**HashSet**

> ==在更改集中的元素时要格外的小心。如果元素的散列码发生了改变，元素在数据结构中的位置也会发生变化==

## 4、树集

​	**TreeSet**类与散列集十分类似，不过，它比散列集有所改进。==树集是一个**有序集合（sorted collection）**。==可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。*例如，假设插入3个字符串，然后访问添加的所有元素。*

```java
SortedSet<String> sorter = new TreeSet<String>(); // TreeSet implement SortedSet
sorter.add("Bob");
sorter.add("Amy");
sorter.add("Carl");
for (String s : sorter)
    System.out.println(s);
```

​	*这时，每个值按照顺序打印出来：Amy Bob Carl。*正如**TreeSet**类名所示，排序是用树结构完成的（当前实现使用的是**红黑树（red-black tree）**。每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

​	将一个元素添加到树中要比添加到散列表中慢，但是，与将元素添加到数组或链表的正确位置上相比还是快很多的。如果树中包含n个元素，查找新元素的正确位置平均需要**log~2~n**次比较



## 5、对象的比较

​	在默认情况下，树集假定插入的元素实现了**Comparable**接口。这个接口定义了一个方法：

```java
public interface Comparable<T>
{
    int compareTo(T other);
}
```

​	如果a与b相等，调用**a.compareTo(b)**一定返回0；如果排序后a位于b之前，则返回负值；如果a位于b之后，则返回正值。*String类的**compareTo**方法依据字典序（有时称为词典序）对字符串进行比较*

​	如果要插入自定义的对象，就必须通过实现**Comparable**接口自定义排序。在**Object**类中，没有提供任何**compareTo**接口的默认实现

​	使用**Comparable**接口定义排列排序有其局限性。对于一个给定的类，只能够实现这个接口一次。而如果在不同的集合中要按照不同的方式进行排序，在这种情况下，可以通过将**Comparator**对象传递给**TreeSet**构造器来告诉树集使用不同的比较方法。**Comparator**接口声明了一个带有两个显式参数的**compare**方法

```java
public interface Comparator<T>
{
    int compare(T a,T b);
}
```

​	如果构造了一棵带比较器的树，就可以在需要比较两个元素时使用这个对象。

```java
SortedSet<Item> sortByDescription = 
    new TreeSet<Item>(new Comparator<Item>()
                      {
                          public int compare(Item a,Item b)
                          {
                              String descrA = a.getDescription();
                              String descrB = b.getDescription();
                              return descrA.compareTo(descrB);
                          }
                      });
```

> 实际上，**Comparator<T>**接口声明了两个方法：**compare**和**equals**。当然，每一个类都有一个**equals**方法；因此，为这个接口声明再添加一个**equals**方法似乎没有太大好处。API文档解释说，不需要覆盖**equals**方法，但这样做可能会在某些情况下提高性能。*例如，如果从另一个集合添加元素，这个由使用相同比较器的另外一个集添加元素，**TreeSet**类中的**addAll**方法的效率会更高。*

> 从java SE 6 起，**TreeSet**类实现了**NavigableSet**接口。这个接口增加了几个便于定位元素以及反向遍历的方法。



## 6、队列与双端队列

​	队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。==有两个端头的队列，即**双端队列**==，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。在java SE 6中引入了**Deque**接口，并由**ArrayDeque**和**LinkedList**类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。



## 7、优先级队列

​	==**优先级队列（priority queue）**中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。==也就是说，无论何时调用**remove**方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构，称为**堆（heap）**。==堆是一个可以自我调整的二叉树，对树执行添加（add）和删除（remove）操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。==

​	与**TreeSet**一样，一个优先级队列既可以保存实现了**Comparable**接口的类对象，也可以保存在构造器中提供比较器的对象

​	

## 8、映射表

​	==**映射表（map）**用来存放键/值对。==如果提供了键，就能够查找到值。

​	java类库为映射表提供了两个通用的实现：**HashMap**和**TreeMap**。这两个类都实现了Map接口

​	散列映射表对键进行散列，树映射表用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。

​	键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用**put**方法，第二个值就会取代第一个值。实际上，==**put**将返回用这个键参数存储的上一个值。==

​	集合框架并没有将映射表本身视为一个集合（其他的数据结构框架则将映射表视为对（pairs）的集合，或者视为用键作为索引的值的集合）。然而，可以获得映射表的视图，这是一组实现了**Collection**接口对象，或者它的子接口的视图

​	有3个视图，它们分别是：键集、值集合和键/值对集。键与键/值对形成了一个集，这是因为在映射表中一个键只能有一个副本。下列方法将返回这3个视图。

    ```java
Set<K> keySet();
Collection<K> values();
Set<Map,Entry<K,V>> entrySet();
    ```

​	注意，**keySet**既不是**HashSet**，也不是**TreeSet**，而是实现了**Set**接口的某个其他类的对象。**Set**接口扩展了**Collection**接口。因此，可以与使用任何集合一样使用**keySet**

> 如果调用迭代器的**remove**方法，实际上就从映射表中删除了键以及对应的值。但是，不能将元素添加到键集的视图中。如果只添加键而不添加值是毫无意义的。如果视图调用**add**方法，将会抛出一个**UnsupportedOperationException**异常。条目集视图也有同样的限制，不过，从概念上讲，添加新的键/值对是有意义的。



## 9、专用集与映射表类

### 1):弱散列映射表（WeakHashMap)

​	假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键/值对无法从映射表中删除。

​	垃圾回收器跟踪活动的对象。只要映射表对象是活动的，其中的所有桶也是活动的，它们不能被回收。因此，需要由程序负责从长期存放的映射表中删除那些无用的值。或者使用**WeakHashMap**完成这件事情。当对键的唯一引用来自散列表条目时，这一数据结构将与垃圾回收器协同工作一起删除键/值对。

​	这种机制的内部运行情况：**WeakHashMap**使用**弱引用（weak references）**保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列表键。对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。**WeakHashMap**将周期性地检查队列，以便找出新添加的弱引用。一个弱引用放入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，**WeakHashMap**将删除对应的条目。

### 2):链接散列集和链接映射表

​	java SE 1.4增加了两个类：**LinkedHashSet**和**LinkedHashMap**，用来记住插入元素项的顺序。这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中，如图。

![image-20200105205501859](D:\Typora\data\javaSE\集合\images\具体的集合.assets\image-20200105205501859.png)

​	链接散列映射表将用访问顺序，而不是插入顺序，对映射表条目进行迭代。每次调用**get**或**put**，受到影响的条目将从当前的位置删除，并放到条目链表的尾部（只有条目在链表中的位置会受影响，而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要想构造这样一个的散列映射表，调用

```java
LinkedHashMap<K,V>(initialCapacity,loadFactor,true)
```

​	访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。*例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。*当在表中找不到元素项且表又已经满时，可以将迭代器加入到表中，并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。甚至可以让这一过程自动化。即构造一个**LinkedHashMap**的子类，然后覆盖下面这个方法：

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest)
```

​	每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。



### 3):枚举集与枚举映射表

​	**EnumSet**是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以**EnumSet**内部用位序列实现。如果对应的值在集中，则相应的位被设置为1。

​	**EnumSet**类没有公共的构造器。可以使用静态工厂方法构造这个集：

```java
enum Weekday{MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY};
EnumSet<Weekday> always = EnumSet.addOf(Weekday.calss);
EnumSet<Weekday> never = EnumSet.noneOf(Weekday.calss);
EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);
EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY);
```

​	可以使用**Set**接口的常用方法来修改**EnumSet**

​	**EnumMap**是一个键类型为枚举类型的映射表。它可以直接且高效地用一个值数组实现。在使用时，需要在构造器中指定键类型：

```java
EnumMap<Weekday,Employee> personInCharge = new EnumMap<Weekday,Employee>(Weekday.class);
```

> 在**EnumSet**的API文档中，将会看到**E extends Enum<E>**这样奇怪的类型参数。简单地说，它的意思是“E是一个枚举类型。”所有的枚举类型都扩展与泛型Enum类。*例如，**Weekday**扩展与**Enum<Weekday>**.



### 4):标识散列映射表

​	java SE 1.4还为另外一个特殊目的增加了另一个类**IdentityHashMap**。在这个类中，键的散列值不是用**hashCode**函数计算的，而是用**System.identityHashCode**方法计算的。这是**Object.hsahCode**方法根据对象的内存地址来计算散列码时所使用的方式。而且，==在对两个对象进行比较时，**IdentityHashMap**类使用\==，而不使用**equals**。==

​	也就是说，不同的键对象，即使内容相同，也被视为是不同的对象。在实现对象遍历算法（如对象序列化）时，这个类非常有用，可以用来跟踪每个对象的遍历状况。















